#ifndef POPULATION_H
#define POPULATION_H

#include "Individual.h"
#include "LocalSearch.h"
#include "Split.h"

typedef std::vector <Individual*> SubPopulation ;

class Population
{
   private:

   Params * params ;				    // Problem parameters
   Split * split;								// Split algorithm
   LocalSearch * localSearch;					// Local search structure
   SubPopulation feasibleSubpopulation;		    // Feasible subpopulation, kept ordered by increasing penalized cost
   SubPopulation infeasibleSubpopulation;		// Infeasible subpopulation, kept ordered by increasing penalized cost
   std::list <bool> listFeasibilityLoad ;		    // Load feasibility of the last 100 individuals generated by LS
   std::list <bool> listFeasibilityDuration ;	// Duration feasibility of the last 100 individuals generated by LS
   std::list <bool> listFeasibilityPack;	        // Pack feasibility of the last 100 individuals generated by LS
   std::vector<std::pair<clock_t, double>> searchProgress; // Keeps tracks of the time stamps of successive best solutions
   Individual bestSolutionRestart;              // Best solution found during the current restart of the algorthm
   Individual bestSolutionOverall;              // Best solution found during the complete execution of the algorithm

   // Evaluates the biased fitness of all individuals in the population:综合考虑了惩罚值的排名和多样性的排名
   //该函数不会改变当前种群的宏观结构，它只是去计算每个个体的适应度值biasedFitness，并储存在个体中.
   void updateBiasedFitnesses(SubPopulation & pop);

   // Removes the worst individual in terms of biased fitness
   //删除当前种群subpop中BiasedFitness最差的一个个体
   //该函数内部会首先计算种群内各个解的BiasedFitness值
   void removeWorstBiasedFitness(SubPopulation & subpop);

   public:

   // Creates an initial population of individuals
   void generatePopulation();

   // Add an individual in the population (survivor selection is automatically triggered whenever the population reaches its maximum size)
   // Returns TRUE if a new best solution of the run has been found
   //第二个参数是用来记录新个体的相关属性的可行性信息：一个解会经过两个阶段，初步改善和修补改善，
   //只有其是经过初步改善的才会计入其相关属性的可行性信息
   //当所要加入种群的当前indiv是目前本次Restart的已知可行最好解时，该函数会返回TRUE
   bool addIndividual (const Individual * indiv, bool updateFeasible);

   // Cleans all solutions and generates a new initial population (only used when running HGS until a time limit, in which case the algorithm restarts until the time limit is reached)
   void restart();

   // Adaptation of the penalty parameters
   //干几件事：第一，根据相关属性队列中的可行比率来调整相应的惩罚系数
   //第二，调整完惩罚系数之后，为非可行解种群中的每个个体重新计算penalizedCost值
   //第三，让非可行解种群中的个体按照更新后的penalizedCost值重新升序排列
   void managePenalties();

   // Select an individal by binary tournament
   //会先分别计算可行解种群和非可行解种群中的每个个体的BiasedFitnesses值
   //基于biasedFitness，二选一
   Individual * getBinaryTournament();

   // Accesses the best feasible individual
   //在printState()函数中进行调用，用于展示
   Individual * getBestFeasible();

   // Accesses the best infeasible individual
   //在printState()函数中进行调用，用于展示
   Individual * getBestInfeasible();

   // Accesses the best found solution at all time
   //返回Population对象中的变量bestSolutionOverall的指针，在main()函数中调用
   Individual * getBestFound();

   // Prints population state
   //在mian()函数中进行调用
   void printState(int nbIter, int nbIterNoImprovement);

   // Returns the average diversity value among the 50% best individuals in the subpopulation
   //在printState()函数中进行调用，用于展示
   double getDiversity(const SubPopulation & pop);

   // Returns the average solution value among the 50% best individuals in the subpopulation
    //在printState()函数中进行调用，用于展示
   double getAverageCost(const SubPopulation & pop);

   // Overwrites a solution written in a file if the current solution is better
   //这个函数是干嘛呢？就是已经知道某个解的已知最好解了，并且将该解存在一个文件中，文件路径BKSpath也在命令行中给出
   //然后这个函数就用来在main()函数中进行检查，看本次程序运行的最好解是不是能超过储存在文件中的已知最好解
   void exportBKS(std::string fileName);

   // Exports in a file the history of solution improvements
   //主要是依次输出Population对象中的searchProgress变量所存的内容，用于展示整个搜索过程解的动态变化
   void exportSearchProgress(std::string fileName, std::string instanceName, int seedRNG);

   // Constructor
   Population(Params * params, Split * split, LocalSearch * localSearch);

   // Destructor
   ~Population();
};

#endif
